0. Search - looking for solutions for various problems.

Search Problems

Terminology
    agent - an entity that perceives its environment, and acts upon that environment
    state - a configuration of the agent in its environment
        initial state - where the agent begins
    actions - choices that can be made in a state
    transition model - a description of the resulting state from performing an action.
        RESULT(s,a) returns the state resulting from performing action a in state s
    state space - the set of all states reachable from the initial state by any sequence of actions
    goal test - a way of determening whether a given state is a goal state
    path cost - numerical cost associated with a given path
    solution - a sequence of actions that leads from the initial state to a goal state
    optimal solution - solution with the lowest path cost among all possible solution

Solving Search Problems:
    Search Problem consist of:
        - initial state
        - actions
        - transition model
        - goal test
        - path cost function

    More Terminology:
        node - a data structure that keeps track of:
            - a state
            - a parent (node that generated this node)
            - an action (action applied to parent to get node)
            - a path cost (from initial state to node)
        Frontier - all the things we could explore that haven't been explored
    
    Approach:
        - Start with a frontier, containing the initial state
        - Repeat:
            - If the frontier is empty, there is no solution.
            - Otherwise, remove a node from the frontier.
            - If the node contains a goal state, return the solution.
            - Otherwise, 'expand' the node, adding resulting nodes to the frontier.
        Decent approach, but doesn't account for nodes that can traverse backwards

    Revised Approach:
        - Start with a frontier,
        - Start with an empty, 'explored' set
        - Repeat:
            - If the frontier is empty, there is no solution.
            - Otherwise, remove a node from the frontier.
            - If the node contains a goal stae, return the solution.
            - Add the node to the explored state
            - Otherwise, 'expand' the node, adding resulting nodes to the frontier, IF they aren't already in the frontier or explored set.
    
    Stack - Last in, first out data-type.
    Queue - First in, first out data-type.
    
    Depth-first search (DFS) - search algorithm that always expands the deepest node in the frontier. Utilizes stacks.

    Breadth-first search (BFS) - search algorithm that always expands the shallowest node in the frontier. Utilizes queues.

Types of Algorithms:
    Uninformed Search - search strategies that use no (problem-specific) knowledge
    Informed Search - search strategies that use problem-specific knowlede to find efficient solutions
        e.g. if i'm in a square closer to the goal, that is better than being in a square farther from the goal.

        Greedy best-first search (GBFS)
         - an (informed) search algorithm that expands the node that is closest to the goal, estimated by a heuristic function h(n)
            - Heuristic Functions - functions that estimate accuracy.
                - Manhatten Distance - type of heuristic that calculates a distance on the x/y plane. (moves in the x or y values. never horizontally)
        A* Search
         - a search aglo that expands the node with the lowest value of g(n) + h(n), with:
            g(n) - cost to reach node
                from n=0, how many steps taken
            h(n) - estimated cost to reach goal
                same heuristic distance from goal

            A* search is optimal if:
             - h(n) is admissable, never overestimates the cost
             - h(n) is consistent. 
                For n' = previous distance, and c = cost from h(n) to h(n');
                h(n) must be less than or equal to h(n'). h(n) <= h(n') + c
        
        Adversarial Search
         - An algorithm has an opposing goal.
        
        Minimax
         - Game:
            - S(0): initial state
            - PLAYER(s): returns which player to move in state S
            - ACTION(s): returns legal (possible) moves in state s
            - RESULT(s, a): returns state after action a taken in state s
            - TERMINAL(s): checks if state s is a terminal state
        
         Pseudocode of Minimax
            - Given a state s:
                - MAX picks action a in ACTIONS(s) that 
            produces highest value of MinValue(RESULTS(s,a))
            - MIN picks action a in ACTIONS(s) that 
              produces smallest value of MaxValue(RESULTS(s,a))
        
            - Alpha-Beta Pruning
                - algorithm that prunes [irrelevant] nodes in a tree by comparing two nodes of different values.
                - Hence, alpha-beta.

        Depth-Limited Minimax
         Limits the amount of actions being considered.
        
         Evaluation Function:
            - Function that estimates the expected utility of the game from a given state
