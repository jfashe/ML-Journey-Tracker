0. Search - looking for solutions for various problems.

Search Problems

Terminology
    agent - an entity that perceives its environment, and acts upon that environment
    state - a configuration of the agent in its environment
        initial state - where the agent begins
    actions - choices that can be made in a state
    transition model - a description of the resulting state from performing an action.
        RESULT(s,a) returns the state resulting from performing action a in state s
    state space - the set of all states reachable from the initial state by any sequence of actions
    goal test - a way of determening whether a given state is a goal state
    path cost - numerical cost associated with a given path
    solution - a sequence of actions that leads from the initial state to a goal state
    optimal solution - solution with the lowest path cost among all possible solution

Solving Search Problems:
    Search Problem consist of:
        - initial state
        - actions
        - transition model
        - goal test
        - path cost function

    More Terminology:
        node - a data structure that keeps track of:
            - a state
            - a parent (node that generated this node)
            - an action (action applied to parent to get node)
            - a path cost (from initial state to node)
        Frontier - all the things we could explore that haven't been explored
    
    Approach:
        - Start with a frontier, containing the initial state
        - Repeat:
            - If the frontier is empty, there is no solution.
            - Otherwise, remove a node from the frontier.
            - If the node contains a goal state, return the solution.
            - Otherwise, 'expand' the node, adding resulting nodes to the frontier.
        Decent approach, but doesn't account for nodes that can traverse backwards

    Revised Approach:
        - Start with a frontier,
        - Start with an empty, 'explored' set
        - Repeat:
            - If the frontier is empty, there is no solution.
            - Otherwise, remove a node from the frontier.
            - If the node contains a goal stae, return the solution.
            - Add the node to the explored state
            - Otherwise, 'expand' the node, adding resulting nodes to the frontier, IF they aren't already in the frontier or explored set.
    
    Stack - Last in, first out data-type.
    Queue - First in, first out data-type.
    
    Depth-first search (DFS) - search algorithm that always expands the deepest node in the frontier. Utilizes stacks.

    Breadth-first search (BFS) - search algorithm that always expands the shallowest node in the frontier. Utilizes queues.

Types of Algorithms:
    Uninformed Search - search strategies that use no (problem-specific) knowledge
    Informed Search - search strategies that use problem-specific knowlede to find efficient solutions
        e.g. if i'm in a square closer to the goal, that is better than being in a square farther from the goal.

Different Search Algorithms:

    Depth-first search (DFS) - search algorithm that always expands the deepest node in the frontier. Utilizes stacks.

    Breadth-first search (BFS) - search algorithm that always expands the shallowest node in the frontier. Utilizes queues.

    Greedy best-first search (GBFS) - an (informed) search algorithm that expands the node that is closest to the goal, estimated by a heuristic function h(n)
        - Heuristic Functions - functions that estimate accuracy.
            - Manhatten Distance - type of heuristic that calculates a distance on the x/y plane. (moves in the x or y values. never horizontally)

    A* Search - a search aglo that expands the node with the lowest value of g(n) + h(n), with:
        g(n) - cost to reach node
            from n=0, how many steps taken
        h(n) - estimated cost to reach goal
            same heuristic distance from goal

        A* search is optimal if:
            - h(n) is admissable, never overestimates the cost
            - h(n) is consistent. 
            For n' = previous distance, and c = cost from h(n) to h(n');
            h(n) must be less than or equal to h(n'). h(n) <= h(n') + c
        
    Adversarial Search
        - An algorithm has an opposing goal.
    
    Minimax
        - Game:
        - S(0): initial state
        - PLAYER(s): returns which player to move in state S
        - ACTION(s): returns legal (possible) moves in state s
        - RESULT(s, a): returns state after action a taken in state s
        - TERMINAL(s): checks if state s is a terminal state
    
        Pseudocode of Minimax
        - Given a state s:
            - MAX picks action a in ACTIONS(s) that 
        produces highest value of MinValue(RESULTS(s,a))
        - MIN picks action a in ACTIONS(s) that 
            produces smallest value of MaxValue(RESULTS(s,a))
    
        - Alpha-Beta Pruning
            - algorithm that prunes [irrelevant] nodes in a tree by comparing two nodes of different values.
            - Hence, alpha-beta.

    Depth-Limited Minimax
        Limits the amount of actions being considered.
    
        Evaluation Function:
        - Function that estimates the expected utility of the game from a given state
